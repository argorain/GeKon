\documentclass[a4paper,11pt]{scrartcl}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
%\usepackage{lmodern}
\usepackage[top=1in, bottom=1in, left=0.75in, right=0.75in]{geometry}
\usepackage[czech]{babel}

\usepackage{minted}
\newminted{ocaml}{fontsize=\footnotesize}
\newminted{cpp}{fontsize=\footnotesize}

\title{GeKon}
\subtitle{Projekt MAPV}
\author{Vojtěch Vladyka a Martin Sehnoutka}

\newcommand{\keyword}{\textbf }

\begin{document}

\maketitle
\tableofcontents

\section{Zadání}
Cílem projektu je navrhnout algoritmus pro indukci konvoluční masky na základě dvou šedotónových nebo barevných obrázků. Pro hledání řešení jsou použité genetické algoritmy. Jako prostředek realizace je zvolena knihovna OpenCV a programovací jazyk C++.

\begin{verbatim}
 +----------+                      +----------+
 | Původní  |                      | Nový     |
 | obrázek  |----> Konvoluce ----> | obrázek  |
 +----------+                      +----------+
\end{verbatim}

\section{Teoretický rozbor}

Práci je možné rozdělit do dvou základních oblastí. První jsou genetické algoritmy, které byly použity pro hledání optimálního řešení. Druhá oblast je zpracování obrazu, jelikož se zabýváme porovnáváním dvou obrázků, námi vytvořeného a zadaného.

Tato sekce je pouhým náznakem principu daných algoritmů, jelikož předpokládáme, že toto není hlavním cílem projektu.

\subsection{Genetické algoritmy}

Jde o heuristický postup, který se snaží aplikovat evoluční principy na optimalizační úlohu. Na rozdíl od analytického výpočtu nepředpokládáme na výstupu exaktní řešení, proto tyto metody používáme v případě, že neznáme analytický postup jak úlohu vyřešit. Celý algoritmus se dá rozdělit na několik kroků, kterým říkáme genetické operátory. Jsou to selekce, křížení a mutace. Tyto operátory potom pracují nad množinou jedinců, kterou nazýváme populace. Jako poslední termín zavádíme fitness funkci, jenž slouží k ohodnocení "výkonnosti" jedince.

\begin{verbatim}
Schéma genetického algoritmu:

  1. Vytvoření počáteční populace
  2. Ohodnocení fitness funkcí
  3. Ukončovací podmínka
      +--> Splněna: Skok na konec 
      +--> Nesplněna: Pokračuj
  4. Selekce
  5. Křížení
  6. Mutace
  7. Elitismus - nejlepšího jedince ponech bez změny
  8. Skok na fitness
\end{verbatim}

\subsection{Selekce}
Naivní řešení by bylo vzít nejlepší jedince ze současné generace a stvořit generaci novou. Tímto postupem bychom se ovšem brzy dostali do lokálního minima, což není žádoucí. Proto zavádíme různé metody selekce, které mají tomuto jevu předcházet tak, že preferují lepší jedince, ale na bázi určité náhody dávají šanci i jedincům horším. V našem projektu implementujeme tyto metody selekce:

\paragraph{Vážená ruleta}
Tato metoda náhodně vybírá jednoho jedince z populace, nicméně lepší jedinci mají vyšší pravděpodobnost. Tato pravděpodobnost je určena poměrem jejich fitness funkcí.

\paragraph{Poziční selekce}
Funguje stejně jako vážená ruleta pouze místo fitness funkce používá pro určení poměrů pravděpodobnosti pozici jedince v pořadí od nejlepšího po nejhoršího. Tato metoda na rozdíl od rulety dává šanci jedincům i v případech, že jejich fitness je podstatně menší než nejlepších jedinců. Tím lze opět eliminovat možnost konvergence do lokálních minim.

\paragraph{Turnaj}
Metoda náhodně vybírá dvojice, ze které vybírá toho lepšího jedince.

\subsection{Křížení}

\paragraph{blx a, simple, convex}

\subsection{Mutace}

\subsection{Zpracování obrazu}

\paragraph{Chybová funkce}

Slouží k ohodnocení podobnosti dvou obrazů, tzn. v našem případě je použita jako fitness funkce pro genetický algoritmus.

\paragraph{Kvadrát rozdílu obrazových funkcí}

Jedná se o naivní implementaci porovnání dvou obrazů, která se dá popsat tímto vzorcem:
\begin{equation}
  error = \sqrt{\sum\limits_{\forall r} \sum\limits_{\forall c} ( O_{r,c} - Y_{r,c} )^2}
\end{equation}

Kde $O$ je vzor upravený neznámým konvolučním jádrem a $Y = I \ast k $ je vzor po konvoluci s kandidátním řešením. $r,c$ jsou obrazové souřadnice.

Tato funkce ovšem vykazuje opačné chování, než jsme od fitness funkce chtěli, klesá s lepším kandidátem a roste s horším. Proto jsme vzorec upravili, aby vyhovoval našim potřebám.
\begin{equation}
  fitness = \sqrt{\frac{rows \cdot cols}{{\sum\limits_{\forall r} \sum\limits_{\forall c} ( O_{r,c} - Y_{r,c} )^2}}}
\end{equation}

Nicméně ani tato fitness funkce nebyla vyhovující neboť dostatečně nerozlišovala dobré a špatné kandidáty, proto jsme ji upravili do finální podoby:
\begin{equation}
  fitness_{new} = e ^ {5 \cdot fitness}
\end{equation}

Kde hodnota 5 byla určena experimentálně.

\paragraph{IQA algoritmy}

IQA ...

\section{Implementace}
Jak již bylo zmíněno, implementace byla provedena v jazyku C++ a to s pomocí knihovny OpenCV. Samozřejmě jsme nepoužili pouze tuto knihovnu, ale rovněž STL, Google test framework, boost atd. I přes použitý jazyk, jsme implementaci neprovedli čistě objektově. Většina základních funkcí (jako jsou na příklad genetické operátory) jsou definovány jako prosté funkce, u kterých byl důraz kladen na ortogonalitu a modularitu, abychom mohli jednoduše zkoušet různé kombinace námi implementovaných operátorů. Nicméně pro pohodlné použití jsme vytvořili jednu třídu příhodně nazvanou Worker, která zapouzdřuje celý genetický algoritmus, ta obsahuje parametry generace a ukazatele na použité operátory.

Testování programu je možné pomocí dvou spustitelných souborů. První z nich je "gekon\_run", který jako parametry přebírá velikost konvolučního jádra a vstupní obrázky, nicméně nelze měnit parametry algoritmu neboť jsou, jak by se řeklo v IT žargonu, "hardcoded" ve zdrojovém souboru. Tento problém řeší druhý spustitelný soubor, který je pojmenován "automated\_tests" a přebírá konfigurační soubor napsaný v jazyku TOML, ten pak definuje parametry testů jako jsou např. velikost generace, použité operátory a počet vláken.

Struktura projektu:
\begin{verbatim}
. -- bin -- spustitelné soubory
  |- docs -- dokumentace
  |- gekon -- zdrojové kódy
  |- samples -- testovací vzory
  |- tests -- unit testy
\end{verbatim}

Ukázka rozhraní jednotlivých funkcí:
\begin{cppcode}
typedef std::function<std::vector<candidate_t>(candidate_t, candidate_t)> crossover_fcn_t;
typedef std::function<void(candidate_t&, unsigned int, unsigned int)> mutation_fcn_t;
typedef std::function<double(tr_sample_t, candidate_t)> fitness_fcn_t;
typedef std::function<population_t(population_t)> selection_fcn_t;
\end{cppcode}

\section{Zhodnocení dosažených výsledků}
%TODO: 

\section{Použitá literatura}
%TODO: Doplnit i další zdroje

HONZÍK, Petr. Strojové učení [online]. Brno, 2006. Dostupné také z: www.vutbr.cz

\end{document}
